#!/usr/bin/env python3
"""
Natural Language Mission Planning Agent for KNR DroneController.

Tools are imported from drone_tools.py module.
Uses Anthropic Claude API with LangChain/LangGraph.

Generated missions use DroneController from drone_autonomy package
and are run via: ./run_test_mission.sh or ros2 run
"""

import uuid
import os
from typing import Literal, TypedDict
from datetime import datetime
import math
from langchain_anthropic import ChatAnthropic
from langgraph.types import Command, interrupt
from langgraph.graph import END, START, StateGraph
from langgraph.checkpoint.memory import InMemorySaver
#wspÃ³Å‚rzedne geograficzne do obliczeÅ„ dystansu
HOME_LATITUDE = 52.229770
HOME_LONGITUDE = 21.011780
EARTH_RADIUS_METERS = 6371000
# Import narzÄ™dzi z osobnego pliku
from drone_tools import (
    DRONE_TOOLS,
    ALLOWED_COMMANDS,
    get_tool_descriptions,
    is_valid_command,
    list_tools
)
from dotenv import load_dotenv
load_dotenv()

# ============================================================================
# Data Types
# ============================================================================
#Obliczanie odlegÅ‚oÅ›ci miÄ™dzy dwoma punktami GPS
def haversine_distance(lat1: float, lon1: float, lat2: float, lon2: float) -> float:
    """
    Oblicza odlegÅ‚oÅ›Ä‡ miÄ™dzy dwoma punktami GPS uÅ¼ywajÄ…c formuÅ‚y haversine.
    """
    lat1_rad = math.radians(lat1)
    lat2_rad = math.radians(lat2)
    delta_lat = math.radians(lat2 - lat1)
    delta_lon = math.radians(lon2 - lon1)
    
    a = math.sin(delta_lat / 2) ** 2 + \
        math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(delta_lon / 2) ** 2
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))
    return EARTH_RADIUS_METERS * c

class ParsedMission(TypedDict):
    waypoints: list[dict]
    estimated_duration_seconds: int
    max_altitude_meters: float
    max_distance_meters: float
    total_distance_meters: float
    summary: str
    warnings: list[str]


class MissionValidation(TypedDict):
    is_safe: bool
    requires_confirmation: bool
    issues: list[str]
    risk_level: Literal["low", "medium", "high", "critical"]

#pamiÄ™c agenta 
class MissionAgentState(TypedDict):
    user_input: str
    language: Literal["pl", "en"] | None
    is_valid_mission: bool | None
    parsed_mission: ParsedMission | None
    validation: MissionValidation | None
    ros2_code: str | None
    mission_id: str | None
    error: str | None
    confirmed: bool
    retry_message: str | None
    total_input_tokens: int
    total_output_tokens: int


# ============================================================================
# LLM Setup
# ============================================================================

llm = ChatAnthropic(
    model="claude-sonnet-4-5-20250929",
    temperature=0,
    max_tokens=8900
)

# LLM z podÅ‚Ä…czonymi narzÄ™dziami z drone_tools.py
llm_with_tools = llm.bind_tools(DRONE_TOOLS)


# ============================================================================
# Agent Nodes
# ============================================================================

def validate_user_input(state: MissionAgentState) -> MissionAgentState:
    """
    Sprawdza czy input uÅ¼ytkownika to sensowna misja drona.
    JeÅ›li nie - prosi o ponowne wpisanie.
    """
    validation_prompt = f"""Analyze if this text describes a valid drone mission.
A valid drone mission should contain flight commands like:
- takeoff/start/wystartuj
- fly/move/leÄ‡/jedÅº + direction or coordinates
- hover/wait/poczekaj/zawisaj
- land/lÄ…duj
- return home/wrÃ³Ä‡/rtl
- rotate/obrÃ³Ä‡/yaw
- take photo/zrÃ³b zdjÄ™cie/capture
- speed/prÄ™dkoÅ›Ä‡

User input: "{state['user_input']}"

Reply ONLY with one word:
- "VALID" if this describes a drone mission (even if incomplete or has errors)
- "INVALID" if this is nonsense, random text, or unrelated to drone missions

Examples:
- "takeoff 10m, fly north" â†’ VALID
- "wystartuj i leÄ‡" â†’ VALID  
- "maslo" â†’ INVALID
- "hello how are you" â†’ INVALID
- "10 metrÃ³w do gÃ³ry" â†’ VALID
- "asdfghjkl" â†’ INVALID
"""
    
    response = llm.invoke(validation_prompt)
    result = response.content.strip().upper()
    input_tokens = response.response_metadata.get('usage', {}).get('input_tokens', 0)
    output_tokens = response.response_metadata.get('usage', {}).get('output_tokens', 0)
    if "VALID" in result and "INVALID" not in result:
        return {"is_valid_mission": True, "retry_message": None}
    else:
        lang = state.get("language", "en")
        if lang == "pl":
            msg = "âŒ Nie rozpoznajÄ™ tego jako misji drona. Opisz misjÄ™ uÅ¼ywajÄ…c komend jak: takeoff, fly, hover, land.\nPrzykÅ‚ad: 'wystartuj 10m, leÄ‡ 20m na pÃ³Å‚noc, zawisaj 5s, lÄ…duj'"
        else:
            msg = "âŒ I don't recognize this as a drone mission. Describe a mission using commands like: takeoff, fly, hover, land.\nExample: 'takeoff 10m, fly 20m north, hover 5s, land'"
        return {
            "is_valid_mission": False, 
            "retry_message": msg,
            "total_input_tokens": state.get("total_input_tokens", 0) + input_tokens,
            "total_output_tokens": state.get("total_output_tokens", 0) + output_tokens
        }


def detect_language(state: MissionAgentState) -> MissionAgentState:
    """Wykrywa jÄ™zyk (polski/angielski)."""
    prompt = f"""Detect language. Reply only "pl" or "en".
Text: {state['user_input']}"""
    
    response = llm.invoke(prompt)
    lang = response.content.strip().lower()
    if lang not in ["pl", "en"]:
        lang = "en"
    input_tokens = response.response_metadata.get('usage', {}).get('input_tokens', 0)
    output_tokens = response.response_metadata.get('usage', {}).get('output_tokens', 0)
    return {
        "language": lang,
        "total_input_tokens": state.get("total_input_tokens", 0) + input_tokens,
        "total_output_tokens": state.get("total_output_tokens", 0) + output_tokens
    }


def parse_mission_with_tools(state: MissionAgentState) -> MissionAgentState:
    """
    parsowanie misji z uÅ¼yciem narzÄ™dzi z drone_tools.py.
    NarzÄ™dzia spoza ALLOWED_COMMANDS sÄ… ignorowane.
    """
    
    # Pobierz opisy narzÄ™dzi z moduÅ‚u
    tool_descriptions = get_tool_descriptions()
    
    parse_prompt = f"""You are a drone mission planner. Parse the user's mission into a sequence of tool calls.

AVAILABLE TOOLS (USE ONLY THESE):
{tool_descriptions}

USER MISSION: {state['user_input']}

CRITICAL INSTRUCTIONS:
- DO NOT write any explanation or text
- DO NOT say "I'll parse this" or similar
- ONLY call tools, one after another
- Start IMMEDIATELY with takeoff tool
- Call ALL required tools for the entire mission

RULES:
1. Start with takeoff (required!)
2. Use goto_relative for directions like "fly 10m north" â†’ north=10, east=0, down=0
3. Use goto_global for GPS coordinates
4. Use hover for waiting/holding position
5. Use take_photo when user wants to capture an image
6. End with land or rtl
7. ONLY use tools from the list above

COORDINATE SYSTEM for goto_relative:
- north+ = forward, north- = backward
- east+ = right, east- = left
- down+ = descend, down- = ascend

Parse the mission step by step, calling appropriate tools for each action."""

    try:
        # WywoÅ‚anie LLM z narzÄ™dziami
        response = llm_with_tools.invoke(parse_prompt)
        
        input_tokens = response.response_metadata.get('usage', {}).get('input_tokens', 0)
        output_tokens = response.response_metadata.get('usage', {}).get('output_tokens', 0)
        # Zbieranie wywoÅ‚ania narzÄ™dzi
        waypoints = []
        warnings = []
        max_altitude = 0.0
        total_distance = 0.0
        max_distance_from_home = 0.0  
        photo_count = 0

        current_lat = HOME_LATITUDE
        current_lon = HOME_LONGITUDE
        max_distance_from_home
        
        if hasattr(response, 'tool_calls') and response.tool_calls:
            for tc in response.tool_calls:
                tool_name = tc['name']
                tool_args = tc['args']
                
                #  Czy narzÄ™dzie jest dozwolone  (funkcja z drone_tools)
                if not is_valid_command(tool_name):
                    warnings.append(f"Ignored unknown command: {tool_name}")
                    continue
                
                # Zbuduj waypoint
                waypoint = {"command": tool_name, **tool_args}
                waypoints.append(waypoint)
                
                # Oblicz statystyki
                if tool_name == "takeoff":
                    alt = float(tool_args.get("altitude", 10))
                    max_altitude = max(max_altitude, alt)
                elif tool_name == "goto_relative":
                    north = float(tool_args.get("north", 0))
                    east = float(tool_args.get("east", 0))
                    total_distance += (north**2 + east**2)**0.5
                    # PrzybliÅ¼ona aktualizacja pozycji GPS dla goto_relative
                    # 1 stopieÅ„ szerokoÅ›ci â‰ˆ 111320 m, 1 stopieÅ„ dÅ‚ugoÅ›ci â‰ˆ 111320 * cos(lat) m
                    current_lat += north / 111320
                    current_lon += east / (111320 * math.cos(math.radians(current_lat)))

                    distance_from_home = haversine_distance(
                        HOME_LATITUDE, HOME_LONGITUDE, current_lat, current_lon)
                    max_distance_from_home = max(max_distance_from_home, distance_from_home)
                elif tool_name == "goto_global":
                    target_lat = float(tool_args.get("lat", HOME_LATITUDE))
                    target_lon = float(tool_args.get("lon", HOME_LONGITUDE))
                    alt = float(tool_args.get("alt", 10))
                    max_altitude = max(max_altitude, alt)

                    #obliczanie dystansu od obecnej pozycji do celu
                    segment_distance = haversine_distance(
                        current_lat, current_lon, target_lat, target_lon)
                    total_distance += segment_distance
                    #obliczanie odlegÅ‚oÅ›ci od domu
                    distance_from_home = haversine_distance(
                        HOME_LATITUDE, HOME_LONGITUDE, target_lat, target_lon)
                    max_distance_from_home = max(max_distance_from_home, distance_from_home)

                    #akutalizacja pozycji
                    current_lat = target_lat
                    current_lon = target_lon
                elif tool_name == "rtl":
                    return_distance = haversine_distance(
                        current_lat, current_lon, HOME_LATITUDE, HOME_LONGITUDE)
                    total_distance += return_distance
                    current_lat = HOME_LATITUDE
                    current_lon = HOME_LONGITUDE
                elif tool_name == "take_photo":
                    photo_count += 1
        
        if not waypoints:
            lang = state.get("language", "en")
            if lang == "pl":
                return {"error": "Nie udaÅ‚o siÄ™ przeksztaÅ‚ciÄ‡ misji w poprawne komendy. UÅ¼yj sÅ‚Ã³w: takeoff/wystartuj, fly/leÄ‡, land/lÄ…duj"}
            return {"error": "Could not parse mission into valid commands. Use words like: takeoff, fly, land"}
        
        # Wygeneruj podsumowanie
        summary_prompt = f"Summarize this drone mission in one sentence (max 15 words): {state['user_input']}"
        summary_response = llm.invoke(summary_prompt)
        summary = summary_response.content.strip()
        input_tokens += summary_response.response_metadata.get('usage', {}).get('input_tokens', 0)
        output_tokens += summary_response.response_metadata.get('usage', {}).get('output_tokens', 0)
        
        if photo_count > 0:
            summary += f" ({photo_count} photo(s))"
        
        estimated_duration = len(waypoints) * 5
        for wp in waypoints:
            if wp.get("command") == "hover":
                estimated_duration += int(wp.get("hold_time", 0))
        
        parsed_mission: ParsedMission = {
            "waypoints": waypoints,
            "estimated_duration_seconds": estimated_duration,
            "max_altitude_meters": max_altitude,
            "max_distance_meters": max_distance_from_home,
            "total_distance_meters": total_distance,
            "summary": summary,
            "warnings": warnings
        }
        
        return {"parsed_mission": parsed_mission,
                 "error": None,
                 "total_input_tokens": state.get("total_input_tokens", 0) + input_tokens,
                 "total_output_tokens": state.get("total_output_tokens", 0) + output_tokens}
        
    except Exception as e:
        return {"error": f"Parse failed: {str(e)}"}


def validate_mission(state: MissionAgentState) -> MissionAgentState:
    """Waliduje misjÄ™ pod kÄ…tem bezpieczeÅ„stwa."""
    if state.get("error"):
        return {}
    
    parsed = state.get("parsed_mission")
    if not parsed:
        return {"error": "No mission"}
    
    issues = []
    risk_level = "low"
    requires_confirmation = False
    
    # SprawdÅº wysokoÅ›Ä‡
    max_alt = parsed.get("max_altitude_meters", 0)
    if max_alt > 120:
        issues.append(f"Altitude {max_alt}m exceeds 120m legal limit")
        risk_level = "critical"
        requires_confirmation = True
    elif max_alt > 50:
        issues.append(f"High altitude ({max_alt}m)")
        risk_level = "medium"
        requires_confirmation = True
    
    # SprawdÅº dystans
    max_dist = parsed.get("max_distance_meters", 0)
    if max_dist > 800:
        issues.append(f"Long distance ({max_dist}m) - check RC range")
        risk_level = "medium" if risk_level == "low" else risk_level
        requires_confirmation = True
    total_dist = parsed.get("total_distance_meters", 0)
    if total_dist > 2000:
        issues.append(f"Total flight distance ({total_dist:.0f}m) - check battery capacity")
        risk_level = "critical"
        requires_confirmation = True
    elif total_dist > 1000:
        issues.append(f"Long total flight ({total_dist:.0f}m) - verify battery")
        risk_level = "medium" if risk_level == "low" else risk_level
        requires_confirmation = True
    # SprawdÅº strukturÄ™ misji
    waypoints = parsed.get("waypoints", [])
    if waypoints:
        last_cmd = waypoints[-1].get("command", "")
        if last_cmd not in ["land", "rtl"]:
            issues.append("Mission does not end with landing")
            requires_confirmation = True
        
        first_cmd = waypoints[0].get("command", "")
        if first_cmd != "takeoff":
            issues.append("Mission does not start with takeoff")
            requires_confirmation = True
    
    # Dodaj ostrzeÅ¼enia z parsowania
    if parsed.get("warnings"):
        issues.extend(parsed["warnings"])
        requires_confirmation = True
    
    return {"validation": {
        "is_safe": risk_level != "critical",
        "requires_confirmation": requires_confirmation,
        "issues": issues,
        "risk_level": risk_level
    }}


def generate_ros2_code(state: MissionAgentState) -> MissionAgentState:
    """
    Generuje kod ROS2 uÅ¼ywajÄ…cy DroneController API.
    Mapowanie: tool_name â†’ DroneController.method()
    """
    
    if state.get("error"):
        return {}
    
    parsed = state.get("parsed_mission")
    if not parsed:
        return {"error": "No mission"}
    
    waypoints = parsed.get("waypoints", [])
    mission_id = f"mission_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
    
    # SprawdÅº czy misja zawiera zdjÄ™cia
    has_photos = any(wp.get("command") == "take_photo" for wp in waypoints)
    
    # Generuj kod dla kaÅ¼dego waypointa
    mission_lines = []
    photo_idx = 1
    
    for i, wp in enumerate(waypoints):
        cmd = wp.get("command", "")
        
        # SprawdÅº czy komenda jest dozwolona
        if not is_valid_command(cmd):
            continue
        
        if cmd == "takeoff":
            altitude = float(wp.get("altitude", 10.0))
            mission_lines.append(f"    # Step {i+1}: Takeoff to {altitude}m")
            mission_lines.append(f"    mission.takeoff({altitude})")
            mission_lines.append(f"    time.sleep(3)")
            
        elif cmd == "goto_relative":
            north = float(wp.get("north", 0.0))
            east = float(wp.get("east", 0.0))
            down = float(wp.get("down", 0.0))
            mission_lines.append(f"    # Step {i+1}: Move relative N:{north}, E:{east}, D:{down}")
            mission_lines.append(f"    mission.send_goto_relative({north}, {east}, {down})")
            mission_lines.append(f"    time.sleep(2)")
            
        elif cmd == "goto_global":
            lat = float(wp.get("lat", 0.0))
            lon = float(wp.get("lon", 0.0))
            alt = float(wp.get("alt", 10.0))
            mission_lines.append(f"    # Step {i+1}: Goto GPS ({lat}, {lon}, {alt}m)")
            mission_lines.append(f"    mission.send_goto_global({lat}, {lon}, {alt})")
            mission_lines.append(f"    time.sleep(3)")
            
        elif cmd == "hover":
            hold_time = float(wp.get("hold_time", 5.0))
            mission_lines.append(f"    # Step {i+1}: Hover for {hold_time}s")
            mission_lines.append(f"    time.sleep({hold_time})")
            
        elif cmd == "set_yaw":
            yaw = float(wp.get("yaw", 0.0))
            relative = wp.get("relative", True)
            yaw_rad = yaw * 3.14159 / 180.0
            mission_lines.append(f"    # Step {i+1}: Set yaw to {yaw}Â° (relative={relative})")
            mission_lines.append(f"    mission.send_set_yaw({yaw_rad:.4f}, {relative})")
            mission_lines.append(f"    time.sleep(2)")
            
        elif cmd == "set_speed":
            speed = float(wp.get("speed", 5.0))
            mission_lines.append(f"    # Step {i+1}: Set speed to {speed} m/s")
            mission_lines.append(f"    mission.set_speed({speed})")
            mission_lines.append(f"    time.sleep(1)")
            
        elif cmd == "rtl":
            mission_lines.append(f"    # Step {i+1}: Return to launch")
            mission_lines.append(f"    mission.rtl()")
            mission_lines.append(f"    time.sleep(2)")
            
        elif cmd == "land":
            mission_lines.append(f"    # Step {i+1}: Land")
            mission_lines.append(f"    mission.land()")
            
        elif cmd == "take_photo":
            prefix = wp.get("prefix", f"photo_{photo_idx}")
            mission_lines.append(f"    take_photo(mission, '{prefix}')")
            mission_lines.append(f"    time.sleep(1)")
            photo_idx += 1
    
    mission_code = "\n".join(mission_lines)
    
    # Import dla zdjÄ™Ä‡
    photo_import = ""
    photo_function = ""
    if has_photos:
        photo_import = "from drone_interfaces.srv import MakePhoto"
        photo_function = '''

def take_photo(node, prefix='photo'):
    """Robi zdjÄ™cie przez serwis /make_photo"""
    client = node.create_client(MakePhoto, '/make_photo')
    if not client.wait_for_service(timeout_sec=2.0):
        node.get_logger().warn('Photo service not available!')
        return False
    
    req = MakePhoto.Request()
    req.prefix = prefix
    req.ext = 'jpg'
    
    future = client.call_async(req)
    rclpy.spin_until_future_complete(node, future, timeout_sec=5.0)
    
    if future.result() is not None:
        result = future.result().success
        node.get_logger().info(f'Photo: {result}')
        return 'saved' in result.lower()
    return False
'''
    
    # generacja peÅ‚nego kodu ROS2
    ros2_code = f'''#!/usr/bin/env python3
"""
Auto-generated mission: {mission_id}
Summary: {parsed.get("summary", "N/A")}
Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

DroneController methods used:
- arm() - Arm and set GUIDED mode
- takeoff(altitude) - Take off to altitude
- land() - Land at current position
- rtl() - Return to launch
- send_goto_relative(north, east, down) - Move relative
- send_goto_global(lat, lon, alt) - Move to GPS
- send_set_yaw(yaw_rad, relative) - Set heading
- set_speed(speed) - Set flight speed
"""
import rclpy
import time
from drone_autonomy.drone_comunication import DroneController
{photo_import}
{photo_function}

def main(args=None):
    rclpy.init(args=args)
    mission = DroneController()
    
    print("ğŸš Starting mission: {mission_id}")
    
    # Arm drone
    mission.arm()
    time.sleep(2)
    
    # === MISSION WAYPOINTS ===
{mission_code}
    
    print("âœ… Mission complete!")
    
    mission.destroy_node()
    rclpy.shutdown()

if __name__ == "__main__":
    main()
'''
    
    return {"ros2_code": ros2_code, "mission_id": mission_id}


# ============================================================================
# Routing Functions
# ============================================================================

def route_after_input_validation(state: MissionAgentState) -> Literal["parse_mission_with_tools", "__end__"]:
    """JeÅ›li input jest niepoprawny, konieczna jest ponowna prÃ³ba."""
    if state.get("is_valid_mission"):
        return "parse_mission_with_tools"
    return "__end__"


def route_after_validation(state: MissionAgentState) -> Literal["human_review", "generate_ros2_code", "__end__"]:
    """Routing po walidacji misji."""
    if state.get("error"):
        return "__end__"
    
    validation = state.get("validation", {})
    if validation.get("requires_confirmation"):
        return "human_review"
    return "generate_ros2_code"


def human_review(state: MissionAgentState) -> Command[Literal["generate_ros2_code", END]]:
    """Human-in-the-loop: zatrzymaj i poczekaj na decyzjÄ™."""
    parsed = state.get("parsed_mission", {})
    validation = state.get("validation", {})
    
    review_info = {
        "summary": parsed.get("summary", "N/A"),
        "risk": validation.get("risk_level", "?"),
        "issues": validation.get("issues", []),
        "waypoints": len(parsed.get("waypoints", [])),
        "max_distance_m": parsed.get("max_distance_meters", 0), 
        "total_distance_m": parsed.get("total_distance_meters", 0),
    }
    
    human_decision = interrupt(review_info)
    
    if human_decision.get("approved", False):
        return Command(update={"confirmed": True}, goto="generate_ros2_code")
    return Command(update={"error": "Rejected by user"}, goto=END)


def output_result(state: MissionAgentState) -> MissionAgentState:
    """KoÅ„cowy node - nic nie robi."""
    return {}


# ============================================================================
# Build Graph
# ============================================================================

def build_mission_graph():
    """Buduje graf LangGraph dla agenta misji."""
    builder = StateGraph(MissionAgentState)
    
    # Nodes
    builder.add_node("detect_language", detect_language)
    builder.add_node("validate_user_input", validate_user_input)
    builder.add_node("parse_mission_with_tools", parse_mission_with_tools)
    builder.add_node("validate_mission", validate_mission)
    builder.add_node("human_review", human_review)
    builder.add_node("generate_ros2_code", generate_ros2_code)
    builder.add_node("output_result", output_result)
    
    # Edges
    builder.add_edge(START, "detect_language")
    builder.add_edge("detect_language", "validate_user_input")
    
    builder.add_conditional_edges(
        "validate_user_input",
        route_after_input_validation,
        ["parse_mission_with_tools", "__end__"]
    )
    
    builder.add_edge("parse_mission_with_tools", "validate_mission")
    
    builder.add_conditional_edges(
        "validate_mission",
        route_after_validation,
        ["human_review", "generate_ros2_code", "__end__"]
    )
    
    builder.add_edge("generate_ros2_code", "output_result")
    builder.add_edge("output_result", END)
    
    return builder.compile(checkpointer=InMemorySaver())


# ============================================================================
# CLI
# ============================================================================

def print_banner():
    print(f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘       ğŸš KNR Drone Mission Planner (Natural Language)             â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  ğŸ“ Home position: {HOME_LATITUDE}, {HOME_LONGITUDE}              â•‘
â•‘                                                                   â•‘
â•‘  Examples:                                                        â•‘
â•‘  â€¢ "takeoff 10m, fly 20m north, hover 5s, land"                   â•‘
â•‘  â€¢ "wystartuj 15m, leÄ‡ 30m pÃ³Å‚noc, zrÃ³b zdjÄ™cie, lÄ…duj"           â•‘
â•‘  â€¢ "takeoff 10m, goto 52.2305,21.0120, land"                      â•‘
â•‘                                                                   â•‘
â•‘  Commands: 'quit' | 'help' | 'tools'                              â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    """)


def get_output_dir():
    """ZwrÃ³Ä‡ katalog, w ktÃ³rym siÄ™ znajduje ten skrypt."""
    return os.path.dirname(os.path.abspath(__file__))


def run_interactive():
    """GÅ‚Ã³wna pÄ™tla interaktywna."""
    print_banner()
    app = build_mission_graph()
    output_dir = get_output_dir()
    
    print(f"ğŸ“ Output directory: {output_dir}\n")
    
    while True:
        try:
            user_input = input("ğŸ¯ Mission: ").strip()
            
            if not user_input:
                continue
            if user_input.lower() in ['quit', 'exit', 'q']:
                break
            if user_input.lower() == 'tools':
                list_tools()  # Funkcja z drone_tools.py
                continue
            if user_input.lower() == 'help':
                print("""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                        HELP - Commands                            â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  ğŸ“ HOME POSITION: {HOME_LATITUDE}, {HOME_LONGITUDE}              â•‘
â•‘     (all distances calculated from this point)                    â•‘
â•‘                                                                   â•‘
â•‘  DIRECTIONS:                                                      â•‘
â•‘    north/south = forward/backward                                 â•‘
â•‘    east/west = right/left                                         â•‘
â•‘    up/down = altitude change                                      â•‘
â•‘                                                                   â•‘
â•‘  ACTIONS (from drone_tools.py â†’ DroneController):                 â•‘
â•‘    takeoff Xm      â†’ mission.takeoff(X)                          â•‘
â•‘    fly Xm north    â†’ mission.send_goto_relative(X, 0, 0)         â•‘
â•‘    goto GPS lat,lon â†’ mission.send_goto_global(lat, lon, alt)    â•‘
â•‘    hover Xs        â†’ time.sleep(X)                               â•‘
â•‘    rotate XÂ°       â†’ mission.send_set_yaw(X, True)               â•‘
â•‘    speed X         â†’ mission.set_speed(X)                        â•‘
â•‘    return home     â†’ mission.rtl()                               â•‘
â•‘    land            â†’ mission.land()                              â•‘
â•‘                                                                   â•‘
â•‘  NOTE: Unknown commands will be ignored!                          â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                """)
                continue
            
            config = {"configurable": {"thread_id": str(uuid.uuid4())}}
            
            initial_state = {
                "user_input": user_input,
                "language": None,
                "is_valid_mission": None,
                "parsed_mission": None,
                "validation": None,
                "ros2_code": None,
                "mission_id": None,
                "error": None,
                "confirmed": False,
                "retry_message": None,
                "total_input_tokens": 0,
                "total_output_tokens": 0
            }
            
            print("â³ Processing mission...")
            result = app.invoke(initial_state, config)
            
            # SprawdÅº czy input byÅ‚ niepoprawny
            if result.get("retry_message"):
                print(result["retry_message"])
                continue
            
            # Handle human review interrupt
            if "__interrupt__" in result:
                data = result["__interrupt__"][0].value
                print(f"\nâš ï¸  Review required!")
                print(f"   ğŸ“ Home: {HOME_LATITUDE}, {HOME_LONGITUDE}") 
                print(f"   Risk level: {data.get('risk', 'unknown')}")
                print(f"   Max distance from home: {data.get('max_distance_m', 0):.1f}m")
                print(f"   Total flight distance: {data.get('total_distance_m', 0):.1f}m")
                print(f"   Issues: {', '.join(data.get('issues', ['None']))}")
                confirm = input("\n   Approve mission? (y/n): ").strip().lower()
                result = app.invoke(
                    Command(resume={"approved": confirm in ['y', 'yes']}), 
                    config
                )
            
            if result.get("error"):
                print(f"âŒ Error: {result['error']}")
            elif result.get("ros2_code"):
                mission_id = result['mission_id']
                pm = result.get("parsed_mission", {})
                lang = result.get("language", "?")

                print(f"\nâœ… Mission generated: {mission_id}")
                print(f"ğŸŒ Language: {lang}")
                print(f"ğŸ“ Summary: {pm.get('summary', 'N/A')}")
                print(f"ğŸ“ Home: {HOME_LATITUDE}, {HOME_LONGITUDE}")
                print(f"ğŸ“ Max distance from home: {pm.get('max_distance_meters', 0):.1f}m")
                print(f"ğŸ“Total flight distance: {pm.get('total_distance_meters', 0):.1f}m")
                input_tokens = result.get("total_input_tokens", 0)
                output_tokens = result.get("total_output_tokens", 0)
                print(f"ğŸª™ Tokens used: Input={input_tokens}, Output={output_tokens}")
                print(f"ğŸ“ Waypoints ({len(pm.get('waypoints', []))}):")
                
                for i, wp in enumerate(pm.get('waypoints', [])):
                    cmd = wp.get('command', '?')
                    params = {k: v for k, v in wp.items() if k != 'command'}
                    params_str = ', '.join(f"{k}={v}" for k, v in params.items()) if params else ""
                    icon = "ğŸ“·" if cmd == "take_photo" else "ğŸ“"
                    print(f"   {icon} {i+1}. {cmd}({params_str})")
                
                save = input("\nğŸ’¾ Save mission? (y/n): ").strip().lower()
                if save in ['y', 'yes']:
                    filepath = os.path.join(output_dir, f"{mission_id}.py")
                    with open(filepath, 'w', encoding='utf-8') as f:
                        f.write(result['ros2_code'])
                    os.chmod(filepath, 0o755)
                    
                    print(f"\nâœ… Saved: {filepath}")
                    print(f"\nğŸ“¦ To run:")
                    print(f"   1. Copy to docker drone_autonomy folder")
                    print(f"   2. Run: ./run_test_mission.sh")
                    print(f"   Or modify run_test_mission.sh to point to {mission_id}.py")
                    
        except KeyboardInterrupt:
            print("\n")
            break
        except Exception as e:
            print(f"âŒ Error: {e}")
            import traceback
            traceback.print_exc()
    
    print("ğŸ‘‹ Goodbye!")


if __name__ == "__main__":
    run_interactive()